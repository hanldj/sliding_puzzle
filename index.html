<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI æ‹¼åœ– - å°ˆæ¥­æµ®å±¤é€šçŸ¥ç‰ˆ</title>
    <style>
        :root { --primary: #3498db; --bg: #f4f7f9; --success: #27ae60; }
        body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); display: flex; flex-direction: column; align-items: center; padding: 15px; margin: 0; }
        
        /* çµ±è¨ˆé¢æ¿ */
        .stats-panel { background: white; padding: 10px 20px; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); width: 100%; max-width: 450px; display: flex; justify-content: space-around; margin-bottom: 12px; }
        .stat-item { text-align: center; }
        .stat-label { color: #888; display: block; font-size: 11px; }
        .stat-val { font-weight: bold; font-size: 18px; color: var(--primary); }

        /* æ­·å²ç´€éŒ„å€å¡Š */
        .history-section { background: white; padding: 12px; border-radius: 12px; width: 100%; max-width: 450px; margin-bottom: 12px; display: none; }
        .history-title { font-size: 12px; color: #666; margin-bottom: 10px; font-weight: bold; }
        .history-list { display: flex; gap: 12px; overflow-x: auto; padding: 5px; }
        .history-container { position: relative; flex-shrink: 0; }
        .history-item { width: 65px; height: 65px; border-radius: 8px; cursor: pointer; object-fit: cover; border: 2px solid transparent; transition: 0.2s; }
        .history-badge { position: absolute; top: -5px; left: -5px; background: var(--primary); color: white; font-size: 10px; width: 18px; height: 18px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-weight: bold; }

        .upload-area { background: white; padding: 15px; border-radius: 12px; width: 100%; max-width: 450px; text-align: center; margin-bottom: 15px; }
        #custom-label { display: block; border: 2px dashed #ccc; padding: 15px; border-radius: 8px; cursor: pointer; color: #666; font-size: 14px; }
        
        #board-container { position: relative; background: #ddd; border: 4px solid #fff; box-shadow: 0 10px 25px rgba(0,0,0,0.1); display: none; overflow: hidden; }
        .tile { position: absolute; box-sizing: border-box; border: 1px solid #fff; background-repeat: no-repeat; transition: transform 0.2s ease-out; cursor: pointer; touch-action: manipulation; }
        .tile.empty { background: none !important; border: none; cursor: default; }
        
        #shuffle-btn { background: var(--primary); color: white; border: none; padding: 12px 30px; border-radius: 25px; font-size: 16px; margin-top: 15px; cursor: pointer; width: 100%; max-width: 450px; display: none; }
        #shuffle-btn:disabled { background: #ccc; }

        /* === æ ¸å¿ƒä¿®æ­£ï¼šç ´é—œå½ˆçª—è¦–çª— (Modal) === */
        #win-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center;
            z-index: 1000; backdrop-filter: blur(4px);
        }
        .win-modal {
            background: white; padding: 30px; border-radius: 20px; text-align: center;
            width: 80%; max-width: 300px; animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .win-modal h2 { color: var(--success); margin-top: 0; }
        .win-modal p { color: #555; margin: 10px 0; }
        .close-btn { background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 20px; margin-top: 15px; cursor: pointer; font-weight: bold; width: 100%; }
    </style>
</head>
<body>

    <div class="stats-panel">
        <div class="stat-item"><span class="stat-label">æ™‚é–“</span><div id="timer" class="stat-val">00:00</div></div>
        <div class="stat-item"><span class="stat-label">æ­¥æ•¸</span><div id="steps" class="stat-val">0</div></div>
        <div class="stat-item"><span class="stat-label">æœ€ä½³ç´€éŒ„</span><div id="best-record" class="stat-val">--:--</div></div>
    </div>

    <div class="history-section" id="history-sec">
        <div class="history-title">æœ€è¿‘éŠç© (1 ç‚ºæœ€æ–°)ï¼š</div>
        <div class="history-list" id="history-list"></div>
    </div>

    <div class="upload-area">
        <label id="custom-label" for="img-input">ğŸ“ é¸æ“‡ç…§ç‰‡æˆ–ç”±æ­·å²æ¸…å–®å•Ÿå‹•</label>
        <input type="file" id="img-input" accept="image/*" style="display:none">
    </div>

    <div id="board-container"></div>
    <button id="shuffle-btn">é–‹å§‹æ´—ç‰Œ</button>

    <div id="win-overlay">
        <div class="win-modal">
            <h2>ğŸ‰ æ­å–œå®Œæˆï¼</h2>
            <p>æœ€çµ‚æ™‚é–“ï¼š<span id="final-time">00:00</span></p>
            <p>æœ€çµ‚æ­¥æ•¸ï¼š<span id="final-steps">0</span></p>
            <div id="new-record-tag" style="display:none; color: #f39c12; font-weight: bold; margin-bottom: 10px;">ğŸ† å‰µä¸‹æ–°ç´€éŒ„ï¼</div>
            <button class="close-btn" onclick="closeWinModal()">å¤ªæ£’äº†</button>
        </div>
    </div>

<script>
    const container = document.getElementById('board-container');
    const input = document.getElementById('img-input');
    const sBtn = document.getElementById('shuffle-btn');
    const timerDisplay = document.getElementById('timer');
    const stepDisplay = document.getElementById('steps');
    const bestDisplay = document.getElementById('best-record');
    const hSec = document.getElementById('history-sec');
    const hList = document.getElementById('history-list');
    const winOverlay = document.getElementById('win-overlay');

    let rows, cols, tiles = [], emptyTile = null;
    let photoUrl = "", stepCount = 0, timerInterval = null, seconds = 0;
    let gameActive = false, hasBeenShuffled = false;

    window.onload = () => displayHistory();

    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => processImage(event.target.result, true);
        reader.readAsDataURL(file);
    };

    function processImage(url, updateOrder = false) {
        const img = new Image();
        img.onload = () => {
            const ratio = img.width / img.height;
            if (ratio >= 1.2) { cols = 4; rows = 3; }
            else if (ratio <= 0.8) { cols = 3; rows = 4; }
            else { cols = 3; rows = 3; }
            photoUrl = url;
            if (updateOrder) saveImageToHistory(url);
            else reorderHistory(url);
            resetStats();
            hasBeenShuffled = false;
            requestAnimationFrame(() => setupBoard());
        };
        img.src = url;
    }

    // ç¸®åœ–å£“ç¸®å„²å­˜
    function saveImageToHistory(url) {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const maxThumb = 200;
            canvas.width = maxThumb; canvas.height = maxThumb;
            const size = Math.min(img.width, img.height);
            ctx.drawImage(img, (img.width-size)/2, (img.height-size)/2, size, size, 0, 0, maxThumb, maxThumb);
            reorderHistory(canvas.toDataURL('image/jpeg', 0.7));
        };
        img.src = url;
    }

    // æ­·å²é †ä½éç§»é‚è¼¯ (1-5 è™Ÿ)
    function reorderHistory(url) {
        let history = JSON.parse(localStorage.getItem('puzzle_history') || "[]");
        history = history.filter(item => item !== url);
        history.unshift(url);
        if (history.length > 5) history = history.slice(0, 5);
        localStorage.setItem('puzzle_history', JSON.stringify(history));
        displayHistory();
    }

    function displayHistory() {
        const history = JSON.parse(localStorage.getItem('puzzle_history') || "[]");
        if (history.length === 0) return;
        hSec.style.display = "block";
        hList.innerHTML = "";
        history.forEach((url, idx) => {
            const wrap = document.createElement('div'); wrap.className = 'history-container';
            const img = document.createElement('img'); img.src = url; img.className = 'history-item';
            img.onclick = () => processImage(url, false);
            const badge = document.createElement('div'); badge.className = 'history-badge'; badge.innerText = idx + 1;
            wrap.appendChild(img); wrap.appendChild(badge); hList.appendChild(wrap);
        });
    }

    function setupBoard() {
        container.innerHTML = ""; container.style.display = "block"; sBtn.style.display = "block";
        const screenW = Math.min(window.innerWidth * 0.9, 450);
        const tSize = Math.floor(screenW / cols);
        const boardW = tSize * cols, boardH = tSize * rows;
        container.style.width = boardW + "px"; container.style.height = boardH + "px";
        tiles = [];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const tile = document.createElement('div'); tile.className = 'tile';
                tile.style.width = tSize + "px"; tile.style.height = tSize + "px";
                updateTileVisual(tile, r, c, tSize);
                tile.style.backgroundImage = `url(${photoUrl})`;
                tile.style.backgroundSize = `${boardW}px ${boardH}px`;
                tile.style.backgroundPosition = `-${c * tSize}px -${r * tSize}px`;
                tile.dataset.targetR = r; tile.dataset.targetC = c;
                if (r === rows - 1 && c === cols - 1) { tile.classList.add('empty'); emptyTile = tile; }
                else { tile.onclick = () => tryMove(tile); }
                container.appendChild(tile); tiles.push(tile);
            }
        }
        updateBestDisplay();
    }

    function updateTileVisual(t, r, c, s) { t.style.transform = `translate(${c * s}px, ${r * s}px)`; t.dataset.currR = r; t.dataset.currC = c; }

    function tryMove(tile, isShuffleLogic = false) {
        if (!isShuffleLogic && !hasBeenShuffled) return false;
        const r = parseInt(tile.dataset.currR), c = parseInt(tile.dataset.currC);
        const er = parseInt(emptyTile.dataset.currR), ec = parseInt(emptyTile.dataset.currC);
        if (Math.abs(r - er) + Math.abs(c - ec) === 1) {
            const tSize = container.offsetWidth / cols;
            updateTileVisual(tile, er, ec, tSize);
            updateTileVisual(emptyTile, r, c, tSize);
            if (!isShuffleLogic && hasBeenShuffled) {
                stepCount++; stepDisplay.innerText = stepCount;
                if (!gameActive) startTimer();
                checkWin();
            }
            return true;
        }
        return false;
    }

    sBtn.onclick = () => {
        resetStats(); let m = 0; const totalM = 120; sBtn.disabled = true; hasBeenShuffled = false;
        const interval = setInterval(() => {
            const er = parseInt(emptyTile.dataset.currR), ec = parseInt(emptyTile.dataset.currC);
            const neighbors = tiles.filter(t => (Math.abs(parseInt(t.dataset.currR) - er) + Math.abs(parseInt(t.dataset.currC) - ec)) === 1);
            tryMove(neighbors[Math.floor(Math.random() * neighbors.length)], true);
            if (++m >= totalM) { clearInterval(interval); sBtn.disabled = false; hasBeenShuffled = true; }
        }, 15);
    };

    function startTimer() { gameActive = true; seconds = 0; timerInterval = setInterval(() => { seconds++; timerDisplay.innerText = formatTime(seconds); }, 1000); }
    function formatTime(s) { const m = String(Math.floor(s / 60)).padStart(2, '0'); const sc = String(s % 60).padStart(2, '0'); return `${m}:${sc}`; }

    function checkWin() {
        if (!hasBeenShuffled || !gameActive) return;
        const win = tiles.every(t => t.dataset.currR == t.dataset.targetR && t.dataset.currC == t.dataset.targetC);
        if (win) {
            clearInterval(timerInterval); gameActive = false;
            // é¡¯ç¤ºå½ˆçª—è¦–çª—
            document.getElementById('final-time').innerText = formatTime(seconds);
            document.getElementById('final-steps').innerText = stepCount;
            winOverlay.style.display = "flex";
            saveRecord();
        }
    }

    function closeWinModal() { winOverlay.style.display = "none"; }

    function saveRecord() {
        const key = `puzzle_best_${cols}x${rows}`;
        const best = localStorage.getItem(key);
        const isNew = (!best || parseInt(best) <= 0 || seconds < parseInt(best));
        if (seconds > 0 && isNew) {
            localStorage.setItem(key, seconds);
            document.getElementById('new-record-tag').style.display = "block";
            updateBestDisplay();
        } else {
            document.getElementById('new-record-tag').style.display = "none";
        }
    }

    function updateBestDisplay() {
        const key = `puzzle_best_${cols}x${rows}`;
        const b = localStorage.getItem(key);
        bestDisplay.innerText = (b && parseInt(b) > 0) ? formatTime(parseInt(b)) : "--:--";
    }

    function resetStats() { clearInterval(timerInterval); seconds = 0; stepCount = 0; timerDisplay.innerText = "00:00"; stepDisplay.innerText = "0"; gameActive = false; }

    window.onkeydown = (e) => {
        if (!emptyTile || sBtn.disabled || !hasBeenShuffled) return;
        const er = parseInt(emptyTile.dataset.currR), ec = parseInt(emptyTile.dataset.currC);
        let tr = -1, tc = -1;
        if (e.key === 'ArrowUp' || e.key === 'w') tr = er + 1, tc = ec;
        else if (e.key === 'ArrowDown' || e.key === 's') tr = er - 1, tc = ec;
        else if (e.key === 'ArrowLeft' || e.key === 'a') tr = er, tc = ec + 1;
        else if (e.key === 'ArrowRight' || e.key === 'd') tr = er, tc = ec - 1;
        if (tr >= 0 && tr < rows && tc >= 0 && tc < cols) {
            const t = tiles.find(tile => tile.dataset.currR == tr && tile.dataset.currC == tc);
            if (t) tryMove(t);
        }
    };
</script>
</body>
</html>
