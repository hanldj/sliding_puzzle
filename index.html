<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‡ªå®šç¾©æ‹¼åœ– - éµç›¤èˆ‡æ‰‹æ©Ÿå„ªåŒ–ç‰ˆ</title>
    <style>
        :root { --primary: #3498db; --bg: #f8f9fa; }
        body { font-family: sans-serif; background: var(--bg); display: flex; flex-direction: center; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        .upload-area { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); width: 100%; max-width: 400px; text-align: center; margin-bottom: 20px; }
        #custom-label { display: block; border: 2px dashed #ccc; padding: 20px; border-radius: 8px; cursor: pointer; color: #666; font-weight: bold; }
        #board {
            width: 90vw; max-width: 400px; aspect-ratio: 1 / 1;
            position: relative; background: #eee; border: 4px solid #fff;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15); display: none; overflow: hidden;
        }
        .tile {
            position: absolute; box-sizing: border-box; border: 1px solid #fff;
            background-repeat: no-repeat; transition: transform 0.15s ease-out;
            cursor: pointer; touch-action: manipulation;
        }
        .tile.empty { background: none !important; border: none; cursor: default; z-index: 0; }
        #shuffle-btn { background: var(--primary); color: white; border: none; padding: 12px 30px; border-radius: 25px; font-size: 16px; margin-top: 15px; cursor: pointer; display: none; width: 100%; }
        #msg { color: #27ae60; font-weight: bold; margin-top: 15px; display: none; font-size: 1.2rem; }
    </style>
</head>
<body>

    <div class="upload-area">
        <h2 style="margin-top:0">ç…§ç‰‡æ‹¼åœ–éŠæˆ²</h2>
        <label id="custom-label" for="img-input">ğŸ“ é»æ“Šæ­¤è™•ä¸Šå‚³/æ‹æ”ç…§ç‰‡</label>
        <input type="file" id="img-input" accept="image/*" style="display:none">
        <button id="shuffle-btn">é–‹å§‹æ´—ç‰Œ</button>
    </div>

    <div id="board"></div>
    <div id="msg">ğŸ‰ æ­å–œå®Œæˆæ‹¼åœ–ï¼</div>

<script>
    /** * æ ¸å¿ƒåŠŸèƒ½ï¼šæ‰‹æ©Ÿä¸Šå‚³æ”¯æ´ã€é›™éµç›¤æ“æ§ (ASDW+æ–¹å‘éµ)
     * é‚è¼¯æº–å‰‡ï¼šæ›¼å“ˆé “è·é›¢èˆ‡æ¨¡æ“¬éš¨æ©Ÿæ´—ç‰Œ */
    const board = document.getElementById('board');
    const input = document.getElementById('img-input');
    const label = document.getElementById('custom-label');
    const sBtn = document.getElementById('shuffle-btn');
    const msg = document.getElementById('msg');

    const GRID = 3;
    let tiles = [];
    let emptyTile = null;
    let photoUrl = "";

    // è™•ç†åœ–ç‰‡ä¸Šå‚³ (æ”¯æ´æ‰‹æ©Ÿèˆ‡é›»è…¦)
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        label.innerText = `å·²è¼‰å…¥: ${file.name}`;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                photoUrl = event.target.result;
                requestAnimationFrame(() => setupBoard());
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    };

    function setupBoard() {
        board.innerHTML = "";
        board.style.display = "block";
        sBtn.style.display = "block";
        msg.style.display = "none";

        const bSize = board.offsetWidth;
        const tSize = bSize / GRID;

        tiles = [];
        for (let r = 0; r < GRID; r++) {
            for (let c = 0; c < GRID; c++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.style.width = tSize + "px";
                tile.style.height = tSize + "px";

                updateTilePosition(tile, r, c);

                tile.style.backgroundImage = `url(${photoUrl})`;
                tile.style.backgroundSize = `${bSize}px ${bSize}px`;
                tile.style.backgroundPosition = `-${c * tSize}px -${r * tSize}px`;

                tile.dataset.targetR = r;
                tile.dataset.targetC = c;

                if (r === GRID - 1 && c === GRID - 1) {
                    tile.classList.add('empty');
                    emptyTile = tile;
                } else {
                    tile.onclick = () => tryMove(tile);
                }

                board.appendChild(tile);
                tiles.push(tile);
            }
        }
    }

    function updateTilePosition(tile, r, c) {
        const tSize = board.offsetWidth / GRID;
        tile.style.transform = `translate(${c * tSize}px, ${r * tSize}px)`;
        tile.dataset.currentR = r;
        tile.dataset.currentC = c;
    }

    function tryMove(tile, checkVictory = true) {
        const r = parseInt(tile.dataset.currentR);
        const c = parseInt(tile.dataset.currentC);
        const er = parseInt(emptyTile.dataset.currentR);
        const ec = parseInt(emptyTile.dataset.currentC);

        // æ›¼å“ˆé “è·é›¢ $Manhattan Distance = |x1 - x2| + |y1 - y2|$
        if (Math.abs(r - er) + Math.abs(c - ec) === 1) {
            const oldR = r, oldC = c;
            updateTilePosition(tile, er, ec);
            updateTilePosition(emptyTile, oldR, oldC);
            if (checkVictory) setTimeout(checkWin, 200);
            return true;
        }
        return false;
    }

    // éµç›¤ç›£è½ç³»çµ±
    window.addEventListener('keydown', (e) => {
        if (!emptyTile || sBtn.disabled) return;

        const er = parseInt(emptyTile.dataset.currentR);
        const ec = parseInt(emptyTile.dataset.currentC);
        let targetPos = { r: -1, c: -1 };

        // åˆ¤å®šæ–¹å‘ï¼šå°‹æ‰¾è¦æ¨å…¥ç©ºæ ¼çš„é‚£é¡†æ–¹å¡Š
        if (e.key === 'ArrowUp' || e.key === 'w') targetPos = { r: er + 1, c: ec };
        else if (e.key === 'ArrowDown' || e.key === 's') targetPos = { r: er - 1, c: ec };
        else if (e.key === 'ArrowLeft' || e.key === 'a') targetPos = { r: er, c: ec + 1 };
        else if (e.key === 'ArrowRight' || e.key === 'd') targetPos = { r: er, c: ec - 1 };

        if (targetPos.r >= 0 && targetPos.r < GRID && targetPos.c >= 0 && targetPos.c < GRID) {
            const targetTile = tiles.find(t =>
                t.dataset.currentR == targetPos.r && t.dataset.currentC == targetPos.c
            );
            if (targetTile) tryMove(targetTile);
        }
    });

    sBtn.onclick = () => {
        let shuffleMoves = 0;
        const totalMoves = 100;
        sBtn.disabled = true;
        msg.style.display = "none";

        const interval = setInterval(() => {
            const er = parseInt(emptyTile.dataset.currentR);
            const ec = parseInt(emptyTile.dataset.currentC);
            const neighbors = tiles.filter(t => {
                const tr = parseInt(t.dataset.currentR);
                const tc = parseInt(t.dataset.currentC);
                return (Math.abs(tr - er) + Math.abs(tc - ec)) === 1;
            });
            tryMove(neighbors[Math.floor(Math.random() * neighbors.length)], false);
            if (++shuffleMoves >= totalMoves) {
                clearInterval(interval);
                sBtn.disabled = false;
            }
        }, 20);
    };

    function checkWin() {
        const isWin = tiles.every(t => t.dataset.currentR == t.dataset.targetR && t.dataset.currentC == t.dataset.targetC);
        if (isWin && !sBtn.disabled) msg.style.display = "block";
    }
</script>
</body>
</html>
