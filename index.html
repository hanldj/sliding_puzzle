<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI æ‹¼åœ– - ç©©å®šéç§»ç‰ˆ</title>
    <style>
        :root { --primary: #3498db; --bg: #f0f3f5; }
        body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); display: flex; flex-direction: column; align-items: center; padding: 15px; margin: 0; }

        /* çµ±è¨ˆé¢æ¿ */
        .stats-panel { background: white; padding: 10px 20px; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); width: 100%; max-width: 450px; display: flex; justify-content: space-around; margin-bottom: 15px; }
        .stat-item { text-align: center; }
        .stat-label { color: #888; display: block; font-size: 11px; }
        .stat-val { font-weight: bold; font-size: 18px; color: var(--primary); }

        /* æ­·å²ç´€éŒ„å€å¡Š */
        .history-section { background: white; padding: 12px; border-radius: 12px; width: 100%; max-width: 450px; margin-bottom: 15px; display: none; }
        .history-title { font-size: 12px; color: #666; margin-bottom: 10px; font-weight: bold; }
        .history-list { display: flex; gap: 12px; overflow-x: auto; padding: 5px; }

        .history-container { position: relative; flex-shrink: 0; }
        .history-item { width: 65px; height: 65px; border-radius: 8px; cursor: pointer; object-fit: cover; border: 2px solid transparent; transition: 0.2s; }
        .history-item:hover { border-color: var(--primary); transform: scale(1.05); }
        .history-badge {
            position: absolute; top: -5px; left: -5px;
            background: var(--primary); color: white;
            font-size: 10px; width: 18px; height: 18px;
            border-radius: 50%; display: flex;
            justify-content: center; align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-weight: bold; pointer-events: none;
        }

        .upload-area { background: white; padding: 15px; border-radius: 12px; width: 100%; max-width: 450px; text-align: center; margin-bottom: 15px; }
        #custom-label { display: block; border: 2px dashed #ccc; padding: 15px; border-radius: 8px; cursor: pointer; color: #666; font-size: 14px; }

        #board-container { position: relative; background: #ddd; border: 4px solid #fff; box-shadow: 0 10px 25px rgba(0,0,0,0.1); display: none; overflow: hidden; }
        .tile { position: absolute; box-sizing: border-box; border: 1px solid #fff; background-repeat: no-repeat; transition: transform 0.2s ease-out; cursor: pointer; touch-action: manipulation; }
        .tile.empty { background: none !important; border: none; cursor: default; }

        #shuffle-btn { background: var(--primary); color: white; border: none; padding: 12px 30px; border-radius: 25px; font-size: 16px; margin-top: 15px; cursor: pointer; width: 100%; max-width: 450px; display: none; }
        #msg { color: #27ae60; font-weight: bold; margin-top: 10px; display: none; text-align: center; font-size: 1.2rem; }
    </style>
</head>
<body>

    <div class="stats-panel">
        <div class="stat-item"><span class="stat-label">æ™‚é–“</span><div id="timer" class="stat-val">00:00</div></div>
        <div class="stat-item"><span class="stat-label">æ­¥æ•¸</span><div id="steps" class="stat-val">0</div></div>
        <div class="stat-item"><span class="stat-label">æœ€ä½³ç´€éŒ„</span><div id="best-record" class="stat-val">--:--</div></div>
    </div>

    <div class="history-section" id="history-sec">
        <div class="history-title">æœ€è¿‘éŠç© (1 ç‚ºæœ€æ–°)ï¼š</div>
        <div class="history-list" id="history-list"></div>
    </div>

    <div class="upload-area">
        <label id="custom-label" for="img-input">ğŸ“ é¸æ“‡ç…§ç‰‡ (æ–°ç…§ç‰‡å°‡æ’åœ¨ 1 è™Ÿé †ä½)</label>
        <input type="file" id="img-input" accept="image/*" style="display:none">
    </div>

    <div id="board-container"></div>
    <button id="shuffle-btn">é–‹å§‹æ´—ç‰Œ</button>
    <div id="msg">ğŸ‰ æ­å–œå®Œæˆæ‹¼åœ–ï¼ ğŸ‰</div>

<script>
    const container = document.getElementById('board-container');
    const input = document.getElementById('img-input');
    const sBtn = document.getElementById('shuffle-btn');
    const timerDisplay = document.getElementById('timer');
    const stepDisplay = document.getElementById('steps');
    const bestDisplay = document.getElementById('best-record');
    const hSec = document.getElementById('history-sec');
    const hList = document.getElementById('history-list');
    const msg = document.getElementById('msg');

    let rows, cols, tiles = [], emptyTile = null;
    let photoUrl = "", stepCount = 0, timerInterval = null, seconds = 0;
    let gameActive = false, hasBeenShuffled = false;

    window.onload = () => displayHistory();

    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => processImage(event.target.result, true);
        reader.readAsDataURL(file);
    };

    function processImage(url, updateOrder = false) {
        const img = new Image();
        img.onload = () => {
            const ratio = img.width / img.height;
            if (ratio >= 1.2) { cols = 4; rows = 3; }
            else if (ratio <= 0.8) { cols = 3; rows = 4; }
            else { cols = 3; rows = 3; }
            photoUrl = url;

            // é‡è¦ï¼šé»æ“ŠèˆŠç¸®åœ–ä¹Ÿæ‡‰è©²æ›´æ–°é †ä½åˆ° 1 è™Ÿ
            if (updateOrder) {
                saveImageToHistory(url);
            } else {
                // å¦‚æœæ˜¯ç›´æ¥é»æ“Šç¸®åœ–ï¼Œä¾ç„¶åŸ·è¡Œä¸€æ¬¡ã€Œç§»å‹•åˆ°é¦–ä½ã€çš„å‹•ä½œ
                reorderHistory(url);
            }

            resetStats();
            hasBeenShuffled = false;
            requestAnimationFrame(() => setupBoard());
        };
        img.src = url;
    }

    // é—œéµä¿®æ­£ 1ï¼šå£“ç¸®åœ–ç‰‡ä»¥é˜²æ­¢å„²å­˜ç©ºé–“çˆ†æ»¿
    function saveImageToHistory(url) {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const maxThumbSize = 200; // ç¸®åœ–å¤§å°
            canvas.width = maxThumbSize;
            canvas.height = maxThumbSize;
            // å°‡åœ–ç‰‡ä¸­å¿ƒè£åˆ‡ä¸¦ç¸®å°
            const size = Math.min(img.width, img.height);
            ctx.drawImage(img, (img.width-size)/2, (img.height-size)/2, size, size, 0, 0, maxThumbSize, maxThumbSize);
            const compressedUrl = canvas.toDataURL('image/jpeg', 0.7); // å£“ç¸®å“è³ª 0.7

            reorderHistory(compressedUrl);
        };
        img.src = url;
    }

    // é—œéµä¿®æ­£ 2ï¼šåš´æ ¼åŸ·è¡Œ 1-5 é †ä½éç§»é‚è¼¯
    function reorderHistory(url) {
        let history = JSON.parse(localStorage.getItem('puzzle_history') || "[]");

        // 1. ç§»é™¤å·²å­˜åœ¨çš„ç›¸åŒåœ–ç‰‡
        history = history.filter(item => item !== url);

        // 2. æ’å…¥åˆ°æœ€å‰é¢æˆç‚º 1 è™Ÿ
        history.unshift(url);

        // 3. åš´æ ¼é™åˆ¶ 5 å¼µï¼Œåˆªé™¤æœ€æœ«ä½
        if (history.length > 5) {
            history = history.slice(0, 5);
        }

        try {
            localStorage.setItem('puzzle_history', JSON.stringify(history));
            displayHistory();
        } catch (e) {
            // å¦‚æœé‚„æ˜¯çˆ†æ»¿ï¼Œæ¸…ç©ºæ­·å²ç´€éŒ„é‡æ–°é–‹å§‹ (ä¿éšªæ©Ÿåˆ¶)
            localStorage.removeItem('puzzle_history');
            console.warn("å­˜å„²ç•°å¸¸ï¼Œå·²é‡ç½®æ­·å²ç´€éŒ„ã€‚");
        }
    }

    function displayHistory() {
        const history = JSON.parse(localStorage.getItem('puzzle_history') || "[]");
        if (history.length === 0) {
            hSec.style.display = "none";
            return;
        }
        hSec.style.display = "block";
        hList.innerHTML = "";

        history.forEach((url, index) => {
            const wrap = document.createElement('div');
            wrap.className = 'history-container';
            const img = document.createElement('img');
            img.src = url;
            img.className = 'history-item';
            img.onclick = () => processImage(url, false);

            const badge = document.createElement('div');
            badge.className = 'history-badge';
            badge.innerText = index + 1;

            wrap.appendChild(img);
            wrap.appendChild(badge);
            hList.appendChild(wrap);
        });
    }

    // --- éŠæˆ²æ¿åˆå§‹åŒ–èˆ‡é‚è¼¯ (ç¶­æŒç©©å®š) ---
    function setupBoard() {
        container.innerHTML = "";
        container.style.display = "block";
        sBtn.style.display = "block";
        const screenW = Math.min(window.innerWidth * 0.9, 450);
        const tSize = Math.floor(screenW / cols);
        const boardW = tSize * cols, boardH = tSize * rows;
        container.style.width = boardW + "px"; container.style.height = boardH + "px";

        tiles = [];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.style.width = tSize + "px"; tile.style.height = tSize + "px";
                updateTileVisual(tile, r, c, tSize);
                tile.style.backgroundImage = `url(${photoUrl})`;
                tile.style.backgroundSize = `${boardW}px ${boardH}px`;
                tile.style.backgroundPosition = `-${c * tSize}px -${r * tSize}px`;
                tile.dataset.targetR = r; tile.dataset.targetC = c;
                if (r === rows - 1 && c === cols - 1) { tile.classList.add('empty'); emptyTile = tile; }
                else { tile.onclick = () => tryMove(tile); }
                container.appendChild(tile);
                tiles.push(tile);
            }
        }
        updateBestDisplay();
    }

    function updateTileVisual(tile, r, c, size) {
        tile.style.transform = `translate(${c * size}px, ${r * size}px)`;
        tile.dataset.currR = r; tile.dataset.currC = c;
    }

    function tryMove(tile, isShuffleLogic = false) {
        if (!isShuffleLogic && !hasBeenShuffled) return false;
        const r = parseInt(tile.dataset.currR), c = parseInt(tile.dataset.currC);
        const er = parseInt(emptyTile.dataset.currR), ec = parseInt(emptyTile.dataset.currC);
        if (Math.abs(r - er) + Math.abs(c - ec) === 1) {
            const tSize = container.offsetWidth / cols;
            updateTileVisual(tile, er, ec, tSize);
            updateTilePositionData(emptyTile, r, c, tSize);
            if (!isShuffleLogic && hasBeenShuffled) {
                stepCount++;
                stepDisplay.innerText = stepCount;
                if (!gameActive) startTimer();
                checkWin();
            }
            return true;
        }
        return false;
    }

    function updateTilePositionData(tile, r, c, size) {
        tile.dataset.currR = r; tile.dataset.currC = c;
        tile.style.transform = `translate(${c * size}px, ${r * size}px)`;
    }

    sBtn.onclick = () => {
        resetStats();
        msg.style.display = "none";
        let m = 0; const totalM = 120;
        sBtn.disabled = true;
        hasBeenShuffled = false;
        const interval = setInterval(() => {
            const er = parseInt(emptyTile.dataset.currR), ec = parseInt(emptyTile.dataset.currC);
            const neighbors = tiles.filter(t => (Math.abs(parseInt(t.dataset.currR) - er) + Math.abs(parseInt(t.dataset.currC) - ec)) === 1);
            tryMove(neighbors[Math.floor(Math.random() * neighbors.length)], true);
            if (++m >= totalM) { clearInterval(interval); sBtn.disabled = false; hasBeenShuffled = true; }
        }, 15);
    };

    function startTimer() { gameActive = true; seconds = 0; timerInterval = setInterval(() => { seconds++; timerDisplay.innerText = formatTime(seconds); }, 1000); }
    function formatTime(s) { const m = String(Math.floor(s / 60)).padStart(2, '0'); const sc = String(s % 60).padStart(2, '0'); return `${m}:${sc}`; }

    function checkWin() {
        if (!hasBeenShuffled || !gameActive) return;
        const win = tiles.every(t => t.dataset.currR == t.dataset.targetR && t.dataset.currC == t.dataset.targetC);
        if (win) { clearInterval(timerInterval); gameActive = false; msg.style.display = "block"; saveRecord(); }
    }

    function saveRecord() {
        const key = `puzzle_best_${cols}x${rows}`;
        const currentBest = localStorage.getItem(key);
        const parsedBest = parseInt(currentBest);
        if (seconds > 0) { if (!currentBest || isNaN(parsedBest) || parsedBest <= 0 || seconds < parsedBest) { localStorage.setItem(key, seconds); updateBestDisplay(); } }
    }

    function updateBestDisplay() {
        const key = `puzzle_best_${cols}x${rows}`;
        const best = localStorage.getItem(key);
        bestDisplay.innerText = (best && parseInt(best) > 0) ? formatTime(parseInt(best)) : "--:--";
    }

    function resetStats() { clearInterval(timerInterval); seconds = 0; stepCount = 0; timerDisplay.innerText = "00:00"; stepDisplay.innerText = "0"; gameActive = false; }

    window.onkeydown = (e) => {
        if (!emptyTile || sBtn.disabled || !hasBeenShuffled) return;
        const er = parseInt(emptyTile.dataset.currR), ec = parseInt(emptyTile.dataset.currC);
        let tr = -1, tc = -1;
        if (e.key === 'ArrowUp' || e.key === 'w') tr = er + 1, tc = ec;
        else if (e.key === 'ArrowDown' || e.key === 's') tr = er - 1, tc = ec;
        else if (e.key === 'ArrowLeft' || e.key === 'a') tr = er, tc = ec + 1;
        else if (e.key === 'ArrowRight' || e.key === 'd') tr = er, tc = ec - 1;
        if (tr >= 0 && tr < rows && tc >= 0 && tc < cols) {
            const t = tiles.find(tile => tile.dataset.currR == tr && tile.dataset.currC == tc);
            if (t) tryMove(t);
        }
    };
</script>
</body>
</html>
